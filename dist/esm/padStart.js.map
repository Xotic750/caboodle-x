{"version":3,"sources":["../../src/padStart.js"],"names":["requireObjectCoercible","_toString","toWholeNumber","isUndefined","_stringSlice","padStart","string","targetLength","str","stringLength","length","fillString","filler","intMaxLength","fillLen","fLen","remainingCodeUnits","truncatedStringFiller"],"mappings":"AAAA;;;;;AAMA,OAAOA,sBAAP,MAAmC,4BAAnC;AACA,OAAOC,SAAP,MAAsB,uBAAtB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,YAAP,MAAyB,0BAAzB;AAEA;;;;;;;;;;;;;;;;;;;AAkBA,eAAe,SAASC,QAAT,CAAkBC,MAAlB,EAA0BC,YAA1B,EAAiD;AAC9D,MAAMC,GAAG,GAAGP,SAAS,CAACD,sBAAsB,CAACM,MAAD,CAAvB,CAArB;;AACA,MAAMG,YAAY,GAAGP,aAAa,CAACM,GAAG,CAACE,MAAL,CAAlC;AACA;;AACA,MAAMC,UAAU,GAAG,wGAAwB,KAAK,CAAhD;AAEA,MAAIC,MAAM,GAAGT,WAAW,CAACQ,UAAD,CAAX,GAA0B,EAA1B,GAA+BV,SAAS,CAACU,UAAD,CAArD;;AAEA,MAAIC,MAAM,KAAK,EAAf,EAAmB;AACjBA,IAAAA,MAAM,GAAG,GAAT;AACD;;AAED,MAAMC,YAAY,GAAGX,aAAa,CAACK,YAAD,CAAlC;;AAEA,MAAIM,YAAY,IAAIJ,YAApB,EAAkC;AAChC,WAAOD,GAAP;AACD;;AAED,MAAMM,OAAO,GAAGD,YAAY,GAAGJ,YAA/B;;AACA,SAAOG,MAAM,CAACF,MAAP,GAAgBI,OAAvB,EAAgC;AAC9B,QAAMC,IAAI,GAAGH,MAAM,CAACF,MAApB;AACA,QAAMM,kBAAkB,GAAGF,OAAO,GAAGC,IAArC;AACAH,IAAAA,MAAM,IAAIG,IAAI,GAAGC,kBAAP,GAA4BZ,YAAY,CAACQ,MAAD,EAAS,CAAT,EAAYI,kBAAZ,CAAxC,GAA0EJ,MAApF;AACD;;AAED,MAAMK,qBAAqB,GAAGL,MAAM,CAACF,MAAP,GAAgBI,OAAhB,GAA0BV,YAAY,CAACQ,MAAD,EAAS,CAAT,EAAYE,OAAZ,CAAtC,GAA6DF,MAA3F;AAEA,SAAOK,qBAAqB,GAAGT,GAA/B;AACD","sourcesContent":["/**\n * @file Pads a string with another string (repeated, if needed).\n * @copyright Copyright (c) 2018-present, Graham Fairweather\n * @module padStart\n */\n\nimport requireObjectCoercible from './requireCoercibleToString';\nimport _toString from './.internal/_toString';\nimport toWholeNumber from './toWholeNumber';\nimport isUndefined from './isUndefined';\nimport _stringSlice from './.internal/_stringSlice';\n\n/**\n * This method pads the current string with another string (repeated, if needed)\n * so that the resulting string reaches the given length. The padding is applied\n * from the start (left) of the current string.\n *\n * @param {string} string - The string to pad.\n * @throws {TypeError} If target is null or undefined.\n * @param {number} targetLength - The length of the resulting string once the\n *  current string has been padded. If the value is lower than the current\n *  string's length, the current string will be returned as is.\n * @param {Array} rest - The rest of the arguments array.\n * @param {string} [rest.padString] - The string to pad the current string with. If\n *  this string is too long to stay within the target length, it will be\n *  truncated and the left-most part will be applied. The default value for this\n *  parameter is \" \" (U+0020).\n * @returns {string} A String of the specified length with the pad string\n *  applied from the start.\n */\nexport default function padStart(string, targetLength, ...rest) {\n  const str = _toString(requireObjectCoercible(string));\n  const stringLength = toWholeNumber(str.length);\n  /* eslint-disable-next-line no-void */\n  const fillString = rest.length ? rest[0] : void 0;\n\n  let filler = isUndefined(fillString) ? '' : _toString(fillString);\n\n  if (filler === '') {\n    filler = ' ';\n  }\n\n  const intMaxLength = toWholeNumber(targetLength);\n\n  if (intMaxLength <= stringLength) {\n    return str;\n  }\n\n  const fillLen = intMaxLength - stringLength;\n  while (filler.length < fillLen) {\n    const fLen = filler.length;\n    const remainingCodeUnits = fillLen - fLen;\n    filler += fLen > remainingCodeUnits ? _stringSlice(filler, 0, remainingCodeUnits) : filler;\n  }\n\n  const truncatedStringFiller = filler.length > fillLen ? _stringSlice(filler, 0, fillLen) : filler;\n\n  return truncatedStringFiller + str;\n}\n"],"file":"padStart.js"}